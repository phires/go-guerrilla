package backends

import (
	"context"
	"strings"

	"github.com/minio/minio-go/v7"
	"github.com/minio/minio-go/v7/pkg/credentials"

	"github.com/phires/go-guerrilla/mail"

	"github.com/phires/go-guerrilla/response"
)

// ----------------------------------------------------------------------------------
// Processor Name: s3
// ----------------------------------------------------------------------------------
// Description   : Saves the raw mail to any compatible S3 storage
//
//	: using the hash generated by the "hash" processor and stored in
//	: e.Hashes
//
// ----------------------------------------------------------------------------------
// Config Options:
//
// --------------:-------------------------------------------------------------------
// Input         : e.Data
//
// ----------------------------------------------------------------------------------
// Output        :
// ----------------------------------------------------------------------------------

var ctx = context.Background()

func init() {
	processors["s3"] = func() Decorator {
		return S3()
	}
}

type S3ProcessorConfig struct {
	Endpoint        string `json:"s3_endpoint"`
	AccessKeyID     string `json:"s3_access_key_id"`
	SecretAccessKey string `json:"s3_secret_access_key"`
	UseTLS          bool   `json:"s3_use_tls"`
	Region          string `json:"s3_region"`
	BucketName      string `json:"s3_bucket_name"`
}

type S3Processor struct {
	config *S3ProcessorConfig
}

func (s *S3Processor) connect() (*minio.Client, error) {

	// Initialize minio client object.
	minioClient, err := minio.New(s.config.Endpoint, &minio.Options{
		Creds:  credentials.NewStaticV4(s.config.AccessKeyID, s.config.SecretAccessKey, ""),
		Secure: s.config.UseTLS,
	})
	if err != nil {
		Log().WithError(err).Error("cannot connect to minio: ", err)
		return nil, err
	}

	// First check, if Bucket exists
	exists, err := minioClient.BucketExists(ctx, s.config.BucketName)
	if err == nil && !exists {
		err = minioClient.MakeBucket(ctx, s.config.BucketName, minio.MakeBucketOptions{Region: s.config.Region})
		if err != nil {
			Log().WithError(err).Error("cannot create bucket: ", err)
			return nil, err
		}
	}
	return minioClient, err
}

func S3() Decorator {
	var config *S3ProcessorConfig
	var client *minio.Client
	s := &S3Processor{}

	// open the database connection (it will also check if we can select the table)
	Svc.AddInitializer(InitializeWith(func(backendConfig BackendConfig) error {
		configType := BaseConfig(&S3ProcessorConfig{})
		bcfg, err := Svc.ExtractConfig(backendConfig, configType)
		if err != nil {
			return err
		}
		config = bcfg.(*S3ProcessorConfig)
		s.config = config
		client, err = s.connect()
		if err != nil {
			return err
		}
		return nil
	}))

	// shutdown is not needed with MinIO client
	Svc.AddShutdowner(ShutdownWith(func() error {
		return nil
	}))

	return func(p Processor) Processor {
		return ProcessWith(func(e *mail.Envelope, task SelectTask) (Result, error) {
			if task == TaskSaveMail {
				hash := ""
				if len(e.Hashes) > 0 {
					hash = e.Hashes[0]
					e.QueuedId = e.Hashes[0]
				}

				r, err := client.PutObject(
					ctx,
					s.config.BucketName,
					hash,
					strings.NewReader(e.String()),
					int64(len(e.String())),
					minio.PutObjectOptions{
						ContentType: "text/plain",
					})

				if err != nil {
					Log().WithError(err).Error("cannot put object: ", err)
				}
				Log().Debugf("successfully uploaded %s of size %d\n", hash, r.Size)

				// continue to the next Processor in the decorator chain
				return p.Process(e, task)
			} else if task == TaskValidateRcpt {
				// if you need to validate the e.Rcpt then change to:
				if len(e.RcptTo) > 0 {
					// since this is called each time a recipient is added
					// validate only the _last_ recipient that was appended
					last := e.RcptTo[len(e.RcptTo)-1]
					if len(last.User) > 255 {
						// return with an error
						return NewResult(response.Canned.FailRcptCmd), NoSuchUser
					}
				}
				// continue to the next processor
				return p.Process(e, task)
			} else {
				return p.Process(e, task)
			}

		})
	}
}
