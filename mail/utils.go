package mail

import (
	"os"
	"mime"
	"strings"
	"github.com/jhillyerd/enmime"
	"fmt"
)


// Wite a file with the given content
func WriteFile(file_path string, decodedContent []byte) error {
	file, err := os.Create(file_path)
	if err != nil {
		return err
	}
	defer file.Close()

	_, err = file.WriteString(string(decodedContent))
	if err != nil {
		return err
	}
	return nil
}

// BuildFileName builds a file name for a MIME part
// If the name is provided in the Content-Disposition header, it will be used.
// Otherwise, a name will be generated based on the radix and index.
func BuildFileName(part *enmime.Part, radix string, index int) (filename string) {

	filename = part.FileName
	if len(filename) > 0 {
		return filename
	}

	mediaType, _, err := mime.ParseMediaType(part.Header.Get("Content-Type"))
	if err == nil {
		mime_type, e := mime.ExtensionsByType(mediaType)

		// Remove any extension not starting with a dot - it should not happen but it might happen
		for i, e := range mime_type {
			if !strings.HasPrefix(e, ".") {
				mime_type = append(mime_type[:i], mime_type[i+1:]...)
			}
		}

		if e == nil {
			if len(mime_type) > 0 { // Arbitrary take the first extension found
				return fmt.Sprintf("%s-%d-autogeneratedfilename%s", radix, index, mime_type[0])
			} else {
				return fmt.Sprintf("%s-%d-autogeneratedfilename.unidentified", radix, index)
			}
		} else { // No extension found
			return fmt.Sprintf("%s-%d-autogeneratedfilename.unknown", radix, index)
		}
	}

	return fmt.Sprintf("%s-%d-autogeneratedfilename.unspecified", radix, index)
}